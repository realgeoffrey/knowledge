# Bash学习笔记

## 目录
1. [模式扩展（globbing）](#模式扩展globbing)
1. [命令行](#命令行)
1. [转义符`\`](#转义符)
1. [字符串](#字符串)
1. [变量](#变量)
1. [算数运算](#算数运算)
1. [脚本（script）](#脚本script)
1. [条件判断](#条件判断)
1. [循环](#循环)
1. [函数](#函数)
1. [数组](#数组)
1. [默认环境变量](#默认环境变量)
1. [启动Bash](#启动bash)

---
>Linux一切皆文件。

### 模式扩展（globbing）
>Shell接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元（token）。然后，Shell会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。

1. `$变量名`或`${变量名}`

    >加花括号`{}`是为了帮助解释器识别变量的边界。e.g. 可以：`echo ${变量1}__${变量2}`或`echo ${变量1}__$变量2`；不可以： ~~`echo $变量1__$变量2`~~ 或 ~~`echo $变量1__${变量2}`~~。

    1. `${!变量名}`

        输出以 变量名返回值 作为变量名 返回的值。
    2. `${!字符串*}`或`${!字符串@}`：

        返回所有匹配给定字符的变量名。
    3. `${#变量名}`：

        获取字符串长度。
    4. `${变量名:开始:长度}`：

        提取子字符串。开始可负，长度可空可负。
    5. 字符串**头部**（`#`）、**尾部**（`%`）、**任意位置**（`/`）的模式匹配

        检查字符串开头、尾部、任意位置，是否匹配给定的模式（支持`*`、`?`、`[]`、等通配符）。若匹配成功，则删除匹配的部分，返回剩下的部分。原始变量不会发生变化。

        1. `${变量名#pattern}`、`${变量名%pattern}`：

            删除最短匹配（非贪婪匹配）的部分，返回剩余部分。
        2. `${变量名##pattern}`、`${变量名%%pattern}`、`${变量名/pattern}`或`${变量名/pattern/}`：

            删除最长匹配（贪婪匹配）的部分，返回剩余部分。

        - `${变量名/#pattern/替换内容}`、`${变量名/%pattern/替换内容}`、`${变量名/pattern/替换内容}`：

            最长匹配（贪婪匹配）进行替换（仅第一个匹配）。
        - `${变量名//pattern/替换内容}`

            最长匹配（贪婪匹配）进行替换所有匹配。
    6. 改变大小写

        1. `${变量名^^}`：

            转为大写。
        2. `${变量名,,}`：

            转为小写。
    7. 若变量值包含连续空格、制表符、换行符，最好放在双引号里面读取，可以保留输出格式。

        >e.g. `a="1  2 3"; echo $a; echo "$a"`
2. `$(命令)`或`` `命令` ``

    扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。

    ><details>
    ><summary>e.g.</summary>
    >
    >```shell
    >echo "Today is $(date). A fine day."    # 先计算出`date`，再传给`echo`。
    >export res=$(curl baidu.com)            # 先`curl`返回内容，再赋值给`res`
    >```
    ></details>

    - 可以嵌套

        >e.g. `echo $(ls $(pwd))`
3. `$((运算))`

    扩展成运算的结果。
4. `~`

    1. `~`：当前用户的主目录
    2. `~用户名`：用户名的主目录
    3. `~+`：当前所在的目录，等同于`pwd`
5. 属于**文件名扩展**，只有文件确实存在的前提下，才会发生扩展，若没有匹配的文件名，则会原样输出 或 提示错误。

    1. `?`

        代表文件路径里面的任意单个字符，不包括空字符。
    2. `*`

        代表文件路径里面的任意数量的任意字符，包括零个字符。

        1. `*`不会匹配隐藏文件（以`.`开头的文件），即`ls *`不会输出隐藏文件。若要匹配隐藏文件，则要写成`.*`。
        2. 一层子目录：`ls */*.txt`。二层子目录：`ls */*/.txt`
        3. 零个或多个子目录`ls **/*.txt`

            >注意：部分Node.js库提供的cli命令，其`**/*.*`表示一或多个子目录，e.g. stylelint、prettier。
    3. `[多个字符]`

        代表括号之中的任意一个字符。

        - `[!多个字符]`或`[^多个字符]`：表示匹配不在方括号里面的一个字符。
    4. `[开始字符-结束字符]`

        匹配连续的范围中的一个字符。

        - `[!开始字符-结束字符]`：表示匹配不在方括号里面连续的范围中的一个字符。
    5. `[[:「模式名」:]]`

        1. `[[:alnum:]]`：匹配任意英文字母与数字
        2. `[[:alpha:]]`：匹配任意英文字母
        3. `[[:blank:]]`：空格和 Tab 键。
        4. `[[:cntrl:]]`：ASCII 码 0-31 的不可打印字符。
        5. `[[:digit:]]`：匹配任意数字 0-9。
        6. `[[:graph:]]`：A-Z、a-z、0-9 和标点符号。
        7. `[[:lower:]]`：匹配任意小写字母 a-z。
        8. `[[:print:]]`：ASCII 码 32-127 的可打印字符。
        9. `[[:punct:]]`：标点符号（除了 A-Z、a-z、0-9 的可打印字符）。
        10. `[[:space:]]`：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）。
        11. `[[:upper:]]`：匹配任意大写字母 A-Z。
        12. `[[:xdigit:]]`：16进制字符（A-F、a-f、0-9）。

        - 字符类的第一个方括号`[]`后面，可以加上感叹号`!`，表示否定。

            >e.g. `[![:digit:]]`匹配所有非数字
    6. 量词语法

        1. `?(匹配内容)`：匹配零个或一个模式。
        2. `*(匹配内容)`：匹配零个或多个模式。
        3. `+(匹配内容)`：匹配一个或多个模式。
        4. `@(匹配内容)`：只匹配一个模式。
        5. `!(匹配内容)`：匹配给定模式以外的任何内容。

        >e.g. `ls abc+(.txt|.php)`
6. 不属于~~文件名扩展~~，它会扩展成所有给定的值，而不管是否有对应的文件存在。

    1. `{字符,字符[,字符]}`

        分别扩展成大括号里面的所有值，各个值之间使用逗号`,`分隔（`,`前后不能有空格）。

        1. 大括号可以嵌套

            >e.g. `echo {j{p,pe}g,png} # jpg jpeg png`
        2. 大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。

            >e.g. `echo /bin/{cat,b*}` 基本等价于 `echo /bin/cat; echo /bin/b*`，会先进行`{}`扩展，然后进行`*`扩展。
    2. `{开始字符..结束字符}`

        扩展成一个连续序列。

### 命令行
1. 进入命令行环境以后，用户会看到Shell的提示符

    1. 提示符往往是一串前缀，最后以一个美元符号`$`结尾，用户可以在这个符号后面输入各种命令。
    2. 根用户`root`的提示符，不以美元符号`$`结尾，而以井号`#`结尾，用来提醒用户，现在具有根权限，可以执行各种操作，务必小心，不要出现误操作。

        >这个符号是可以自己定义。
2. 多命令行执行

    >没有逗号 ~~`,`~~ 的多命令行执行语法。

    1. `;`

        命令的结束符，使得一行可以放置多个命令，上一个命令执行结束后，再执行下一个命令。下一个命令总是接着上一个命令执行，不管上一个命令执行成功或失败（无论上一个命令退出码是多少）。
    2. `&&`

        若前一个命令运行成功（退出码：`0`），则继续运行下一个命令。
    3. `||`

        若前一个命令运行失败（退出码：`非0`），则继续运行下一个命令。
3. 快捷键：

    1. `Ctrl + C`：中止当前正在执行的命令。
    2. `Ctrl + D`：关闭Shell的Session。
4. 当在前台运行某个作业时，Shell的Session被该作业占据；可以在命令后面加上`&`实现后台运行

    1. `「命令」 &`

        后台运行。若「命令」产生输出，则会将脚本输出内容显示在Shell的Session上，会影响Session的操作。
    2. `「命令」 > 「文件地址」 2>&1 &`

        后台运行。所有的标准输出、错误输出都将被重定向到「文件地址」中。

        ><details>
        ><summary>命令解析</summary>
        >
        >1. `> 「文件地址」`：将脚本的标准输出重定向到「文件地址」，不打印在屏幕上。
        >2. `2>&1`：将标准出错重定向到标准输出，由于我们的标准输出已经重定向到了「文件地址」，所以标准出错也会输出到「文件地址」。
        ></details>

    >使用`&`命令时，关闭当前控制台窗口或退出当前帐户时，作业就会停止运行。但是当脚本被`./脚本`或`bash ./脚本`（或其他Shell）新建一个子Shell执行，之后关闭当前父级Shell不会停止作业运行。

    3. `nohup`

        `nohup`命令可以在退出帐户或关闭窗口后继续运行进程，用于忽略SIGHUP（signal hang up，挂断信号：终端注销时所发送至程序的一个信号）。

        1. `nohup 「命令」 &`

            后台运行。「命令」的标准输出到 当前目录或`$HOME` 的`nohup.out`。
        2. `nohup 「命令」 > 「文件地址」 2>&1 &`

            后台运行。所有的标准输出、错误输出都将被重定向到「文件地址」中。

    >杀死后台进程：先找到进程id然后`kill`：[查看端口占用、网络链接，查看进程并杀死](https://github.com/realgeoffrey/knowledge/blob/master/工具使用/命令行备忘/README.md#查看端口占用网络链接查看进程并杀死)。

### 转义符`\`
1. 转义：

    特殊字符（`$`、`&`、`*`、`\`、等）、不可打印字符（`\n`换行、`\r`回车、`\t`制表符、等）、任意字符。
2. Bash单个命令一般都是一行，用户按下回车键（换行符），就开始执行。

    有些命令比较长，写成多行会有利于阅读和编辑，这时可以在每一行的结尾（换行符）加上反斜杠`\`，Bash就会将下一行跟当前行放在一起解释（命令行、脚本均适用）。

### 字符串
Bash只有一种数据类型：字符串。不管用户输入什么数据，Bash都视为字符串。

1. 引号

    1. 单引号`''`

        单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符：上面的 `模式扩展` 以及`\`、等（不可打印字符还是可以按效果展示）。

        - 由于反斜杠`\`在单引号里面变成了普通字符，所以若单引号之中，还要使用单引号，则不能使用转义，需要在外层的单引号前面加上一个美元符号`$`，然后再对里层的单引号转义。

            >e.g. `echo $'it\'s'`
    2. 双引号`""`

        除了`$`、`` ` ``、`\`之外，大部分特殊字符在双引号里面，都会失去特殊含义，变成普通字符（不可打印字符还是可以按效果展示）。

        - 保存原始命令的输出格式（空格、制表符、换行符 会保持输出格式，而不会合并或省略）。

            >e.g. `echo "$(cal)"`

2. here document

    1. 内部会发生`$变量名`或`${变量名}`替换，支持反斜杠`\`转义，但是不支持通配符扩展，双引号`""`和单引号`''`也失去语法作用，变成了普通字符。

        ```shell
        <<开始标记
        # 任意内容，可换行
        结束标记
        ```
    2. 若不希望变量替换（其他效果不变），可以把开始标记放在引号中。

        ```shell
        <<'开始标记'或"开始标记"
        # 任意内容，可换行
        # 变量替换取消，$变量名或${变量名}原样输出
        结束标记
        ```

    ```shell
    $ 「command」 << 「token」
      「字符串」
    「token」

    # 等同于

    $ echo 「字符串」 | 「command」
    ```
3. here string

    ```shell
    $ cat <<< 'hi there'
    # 等同于
    $ echo 'hi there' | cat
    ```

### 变量
>变量名区分大小写。

1. 环境变量

    >程序运行的时候，都会读取父Shell的环境变量。通过这点，经常通过环境变量向后台程序传递数据，CI/CD也通过设置和读取环境变量来向接下来运行的服务传递数据。

    可由用户从父Shell自动传入子Shell（子Shell无法影响父Shell的所有变量，包括环境变量、自定义变量）。

    ```shell
    # 设置
    export 「已有的自定义变量名」
    export 「自定义变量名」=「值」
    ```

    >仅支持字符类型。
2. 自定义变量

    无法~~由用户从父Shell传入子Shell~~。自定义变量是用户在当前Shell里面自己定义的变量，仅在当前Shell可用（当前Shell的子或父Shell均不可用）。

    ```shell
    # 设置
    「变量名」=「值」
    ```

    >支持字符串、数组、函数。

- 删除变量（环境变量 + 自定义变量）

    ```shell
    unset 「变量名」 # 删除变量
    「变量名」=''    # 变量值为空，变量还存在
    「变量名」=      # 变量值为空，变量还存在
    ```

`export`、`env`、`printenv`可以查看所有环境变量；`set`、`declare`可以查看所有 环境变量+自定义变量。

- 特殊变量

    1. `$?`或`${?}`

        >每个命令执行完毕都有`退出码`（exit status）。

        返回**上一个**命令的`退出码`，用来判断上一个命令是否执行成功。若返回值是`0`，则表示上一个命令执行成功；否则表示上一个命令执行失败。
    2. `$$`或`${$}`

        返回当前Shell的进程ID。
    3. `$_`或`${_}`

        返回上一个命令的最后一个参数。
    4. `$!`或`${!}`

        返回最近一个后台执行的异步命令的进程ID。
    5. `$-`或`${-}`

        返回当前Shell的启动参数。
    6. `$0`或`${0}`

        返回当前Shell的名称（在命令行直接执行时）或 脚本名（在脚本中执行时）。
    7. 参数相关

        1. `$正整数`或`${正整数}`

            返回脚本或函数的第N个参数。
        2. `$#`或`${#}`

            返回脚本或函数的参数数量。
        3. `$@`或`${@}`

            返回脚本或函数的参数值，每个参数都是独立的。
        4. `$*`或`${*}`

            返回脚本或函数的参数值。若加`""`包裹，则视所有命令参数为一个完整单词；若没有 ~~`""`~~ 包裹，则每个命令参数是独立的（与`$@`或`${@}`一致）。

- 变量默认值

    1. 目的：返回一个默认值

        1. `${「变量名」:-「默认值」}`

            若「变量名」存在且不为空，则返回它的值，否则返回「默认值」。
        2. `${「变量名」-「默认值」}`

            若「变量名」存在，则返回它的值（若「变量名」值为空，则返回空），否则返回「默认值」。
    2. 目的：设置变量的默认值

        1. `${「变量名」:=「默认值」}`

            若「变量名」存在且不为空，则返回它的值，否则将它设为「默认值」并返回。
        2. `${「变量名」=「默认值」}`

            若「变量名」存在，则返回它的值（若「变量名」值为空，则返回空），否则将它设为「默认值」并返回。
    3. 目的：测试变量是否存在

        1. `${「变量名」:+「存在返回值」}`

            若「变量名」存在且不为空，则返回「存在返回值」，否则返回空。
        2. `${「变量名」+「存在返回值」}`

            若「变量名」存在，则返回「存在返回值」（若「变量名」值为空，则返回「存在返回值」），否则返回空。
    4. 目的：防止变量未定义

        1. `${「变量名」:?「信息」}`

            若「变量名」存在且不为空，则返回它的值，否则打印「信息」（若省略了「信息」，则输出参数未设置），并中断脚本的执行。
        2. `${「变量名」?「信息」}`

            若「变量名」存在，则返回它的值（若「变量名」值为空，则返回空），否则打印「信息」（若省略了「信息」，则输出参数未设置），并中断脚本的执行。

    - 上面四种语法若用在脚本中，变量名的部分写成数字，则表示脚本的参数（`0`脚本文件名，`1`脚本的第一个参数，以此类推）

        >e.g. `${11:?}`、`${11?}`

### 算数运算
1. `((运算))`

    >~~`$[运算]`~~ 是以前的语法，也可以做整数运算，不建议使用。

    语法不返回值，命令执行的结果根据算术运算的结果而定。只要算术结果不是 ~~`0`~~，命令就算执行成功（退出码：`0`），否则执行不成功（退出码：`1`）。

    ```shell
    $ ((foo = 5 + 5)) && echo 值不等于0，执行成功（退出码：\`0\`）
    值不等于0，执行成功（退出码：`0`）
    $ echo $foo
    10
    $ (( $foo - 10 ))       # 值等于0，执行不成功（退出码：`1`）
    $ echo $?
    1
    ```

2. `$((运算))`

    语法返回运算结果，无论结果是多少都执行成功（退出码：`0`），其他与`((运算))`类似（变量`=`运算后赋值、无变量则仅运算）。

- `((运算))`、`$((运算))` 的语法：

    1. 运算可以使用变量，变量带不带`$`均可。不存在的变量 或 不是数值的变量（字符串），运算中当做`0`。
    2. 会自动忽略内部空格
    3. 可以用圆括号`()`改变运算顺序

        >e.g. `((a=(5**2) * 3)) && echo $a # 75`
    4. 动态计算变量

        ```shell
        $ foo=hello
        $ hello=3
        $ echo $(( foo + 2 ))
        5
        ```
    5. 数值的进制

        1. `「数字」`：

            十进制。
        2. `0「数字」`：

            八进制。
        3. `0x「数字」`：

            十六进制。
        4. `「进制数」#「数字」`：

            「进制数」进制。

            >e.g. `echo $((4#10)) # 10`
    6. 支持的算数运算符：

        1. `+`
        2. `-`
        3. `*`
        4. `/`
        5. `%`
        6. `**`：指数
        7. `++`、`--`（前缀：先运算后返回值；后缀：先返回值后运算）

        若有小数参与，则返回小数点。否则仅返回整数（向下取整）。
    7. 位运算

        1. `<<`：

            位左移运算，把一个数字的所有位向左移动指定的位。
        2. `>>`：

            位右移运算，把一个数字的所有位向右移动指定的位。

            >无 ~~`>>>`~~ 无符号右移动。
        3. `&`：

            位的“与”运算，对两个数字的所有位执行一个AND操作。
        4. `|`：

            位的“或”运算，对两个数字的所有位执行一个OR操作。
        5. `~`：

            位的“否”运算，对一个数字的所有位取反。
        6. `^`：

            位的异或运算（exclusive or），对两个数字的所有位执行一个异或操作。
    8. 赋值运算

        `=`、`+=`、`-=`、`*=`、`/=`、`%=`、`<<=`、`>>=`、`&=`、`|=`、`^=`
    9. `,`

        多个运算，返回值以最后一个运算为准。
    10. 逻辑运算

        `$((逻辑运算))`：若逻辑表达式为真，则返回`1`，否则返回`0`。`((逻辑运算))`：若逻辑表达式为真，则执行成功（退出码：`0`），否则执行不成功（退出码：`1`）。

        1. `<`：

            小于
        2. `>`：

            大于
        3. `<=`：

            小于或相等
        4. `>=`：

            大于或相等
        5. `==`：

            相等
        6. `!=`：

            不相等
        7. `&&`：

            逻辑与
        8. `||`：

            逻辑或
        9. `!`：

            逻辑否
        10. `expr1?expr2:expr3`：

            三元运算符。若表达式expr1的计算结果为非 ~~`0`~~ 值（算术真），则执行表达式expr2，否则执行表达式expr3。

### 脚本（script）
脚本是包含一系列命令的一个文本文件。Shell读取这个文件，依次执行里面的所有命令，就好像这些命令直接输入到命令行一样。所有能够在命令行完成的任务，都能够用脚本完成。命令错误不会退出脚本，命令全部执行完毕或者遇到`exit`才会退出脚本。

1. shebang行

    ```shell
    #!/bin/sh
    # 或者
    #!/bin/bash
    ```

    脚本的第一行通常是指定`解释器`，即这个脚本必须通过什么解释器执行。这一行以`#!`字符开头（后可跟或不跟空格），这个字符称为Shebang，所以这一行就叫做Shebang行。

    1. `#!` + 脚本解释器的位置

        Bash脚本的解释器一般是`/bin/sh`或`/bin/bash`，也可以是其他语言的解释器。
    2. 若Bash解释器不放在目录`/bin`，则脚本无法执行

        为了保险，可以写成`#!/usr/bin/env 「解释器名」`，如：`#!/usr/bin/env bash或node或python或其他自定义解释器`。
    3. Shebang行不是必需的，但建议加上。若缺少该行，则需要手动将脚本传给解释器

        若包含shebang行，则可直接调用`./脚本`（当前用户拥有执行该文件的权限），否则需要解释器+脚本：`bash ./脚本`（或其他Shell）。

        - 使用`bash ./脚本`（或其他Shell），会完全脚本的忽略Shebang行（Shebang行加的运行参数也会被忽略）。
2. `source`或`.`：在当前Shell执行一个脚本，通常用于重新加载一个配置文件

    >1. `source ./脚本`（`. ./脚本`）：把脚本的语句依次读入当前Shell进行执行，因此改变的变量都会保存在当前Shell（也能读取、操作当前Shell的自定义变量）。
    >2. `./脚本`或`bash ./脚本`（或其他Shell）：新建一个子Shell，并在子Shell里运行脚本（子Shell继承父Shell的环境变量），执行结束后，改变的变量不会带回父Shell。

    - 可以在脚本内部加载外部库，然后就可以在脚本里面，使用这个外部库定义的函数

        ><details>
        ><summary>e.g.</summary>
        >
        >```shell
        >#!/bin/bash
        >
        >source ./lib.sh     # 外部库
        >
        >function_from_lib   # 外部库的变量名（函数名）
        >```
        ></details>
3. 脚本文件的执行权限

    读入文件并执行其内容。

    1. `source`（`.`）或`bash`（或其他Shell）：不需要拥有该文件的执行权限
    2. 直接运行`./脚本`：需要当前用户拥有该文件的执行权限（`chmod 777 「文件」`）
4. 若文件没有路径，则去`$PATH`找

    >e.g. `「执行指令」 「文件」`或`「文件」`去`$PATH`找；`「执行指令」 ./「文件」`或`./「文件」`在指定目录找。

- 脚本指令

    1. `shift 「正整数，默认1」`

        改变脚本参数，每次执行都会移除脚本的前N个参数，使得后面的参数向前N位，若N=1，则`$2`变成`$1`、`$3`变成`$2`、`$4`变成`$3`，以此类推。

        ><details>
        ><summary>e.g.</summary>
        >
        >```shell
        >#!/bin/bash
        >
        ># 若输入3个参数：1 2 3
        >echo "一共输入了 $# 个参数"     # 3
        >
        >while [ "$1" != "" ]; do
        >  echo "剩下 $# 个参数"
        >  echo "参数：$1"
        >  shift
        >done
        >
        >echo "剩下 $# 个参数"        # 0
        >```
        ></details>
    2. `getopts`

        用在脚本内部，可以解析复杂的脚本命令行参数，通常与while循环一起使用，取出脚本所有的带有前置连词线（`-`）的参数。
    3. `--`配置项参数终止符

        `-`、`--`开头的参数，会被Bash当作配置项解释。配置项参数终止符`--`的作用是告诉Bash，在它后面的参数开头的`-`、`--`不是配置项，只能当作实体参数解释。

        >e.g. 新建一个名字为`-l`的文件：`touch -- -l`。
    4. `exit 「退出码，默认上一个命令的退出码」`终止当前脚本的执行，并向Shell返回一个指定退出码

        >退出码只能在`0~255`取值，大于255会`%256`。

        1. 执行正常：`0`
        2. 执行错误：`非0`

            1. `1`：发生错误
            2. `2`：用法不对
            3. `126`：不是可执行脚本
            4. `127`：命令没有发现
            5. `128`：exit参数错误，exit只能以整数作为参数
            6. 若脚本被信号`N`终止，则退出码：`128 + N`
            7. `130`：用Control-C来结束脚本，用Control-C是信号2的致命错误

### 条件判断
1. `test`

    >进行文件操作时，最好确认好所在的文件夹，如：`[[ -d $dir_name ]] && cd $dir_name && echo rm *`。

    ```shell
    # 写法一
    test 「expression」

    # 写法二
    [ 「expression」 ]      # 空格是必须的

    # 写法三
    [[ 「expression」 ]]    # 空格是必须的。支持正则判断
    ```

    若表达式成立，则执行成功（退出码：`0`）。否则执行失败（退出码：`1`）。

    1. 文件判断

        >文件名最好放在双引号中。

        ```shell
        [ -a 「文件名」]

        [ 「文件名1」 -nt 「文件名2」 ]
        ```
    2. 字符串判断

        ```shell
        [ 「字符串」 ]
        [ -n 「字符串」 ]
        [ 「字符串1」 = 「字符串2」 ]
        ```
    3. 整数判断

        ```shell
        [ 「数字1」 -eq 「数字2」 ]
        ```
    4. 正则判断（仅`[[  ]]`支持）

        ```shell
        [[ 「字符串」 =~ 「正则表达式」 ]]
        ```
    5. 逻辑运算

        1. `&&` 或 `-a`
        2. `||` 或 `-o`
        3. `!`
    - `test`命令内部使用圆括号`()`必须使用引号或转义
2. `if`

    ```shell
    # 多行
    if 「condition」; then
      「commands」
    [elif 「condition」; then
      「commands」]             # 可多个`elif-then`
    [else
      「commands」]
    fi

    # 单行
    if 「condition」; then 「commands」;[ elif 「condition」; then 「commands」;][ else 「commands」;] fi
    ```

    1. `if`、`elif`（、`while`、`until`、`for-in`、`for`）后跟的条件判断也是`命令`。若**最后的**命令执行成功（退出码：`0`），则判断条件成立。否则判断条件失败。

        1. `true`和`false`也是命令，分别表示真、假（退出码：`0`、`1`。但不会终止当前Shell）。
        2. 多个命令，仅根据最后一个命令的退出码决定条件是否成立。
    2. 与`(())`配合

        >e.g. 返回真：`if (( 3 > 2 ))`、`if (( 1 ))`。返回假：`if (( 3 < 2 ))`、`if (( 0 ))`
3. `case`

    ```shell
    # 多行
    case 「expression」 in
      「pattern」 )
        「commands」 ;; # 若改成`;;&`，则命中后继续向下匹配
      「pattern」 )
        「commands」 ;;
      ...
    esac

    # 单行
    case 「expression」 in; 「pattern」 ) 「commands」 ;; 「pattern」 ) 「commands」 ;; esac
    ```

    - 匹配模式可以使用各种通配符：

        1. `a)`：匹配a。
        2. `a|b)`：匹配a或b。
        3. `[[:「模式名」:]])`：匹配模式名含义。
        4. `???)`：匹配3个字符的单词。
        5. `*.txt)`：匹配.txt结尾。
        6. `*)`：匹配任意输入，通过作为case结构的最后一个模式。

### 循环
1. `while`

    ```shell
    # 多行
    while 「condition」; do
      「commands」
    done

    # 单行
    while 「condition」; do 「commands」; done
    ```
2. `until`

    与`while`相反，只要不符合条件，就执行。

    ```shell
    # 多行
    until 「condition」; do
      「commands」
    done

    # 单行
    until 「condition」; do 「commands」; done
    ```
3. `for`

    ```shell
    # 多行
    for (( 「expression1 初始化条件」; 「expression2 决定循环结束条件」; 「expression3 每次循环后执行」 )); do
      「commands」
    done

    # 单行
    for (( 「expression1」; 「expression2」; 「expression3」 )); do 「commands」; done


    # 等价于
    (( 「expression1」 ))
    while (( 「expression2」 )); do
      「commands」
      (( 「expression3」 ))
    done
    ```

    - 3个语句都可以省略

        >e.g. `for (( ;; )); do 「commands」; done`
4. `for-in`

    ```shell
    # 多行
    for 「variable」 in 「list」; do
      「commands」
    done

    # 单行
    for 「variable」 in 「list」; do 「commands」; done
    ```

    1. e.g.

        ```shell
        # 列表由多个单词产生
        for i in word1 word2 $PATH; do
          echo $i
        done

        # 列表由通配符产生
        for i in *.png; do
          ls -l $i
        done

        # 列表由子命令产生
        count=0
        for i in $(cat ~/.bash_profile); do
          count=$((count + 1))
          echo "Word $count ($i) contains $(echo -n $i | wc -c) characters"
        done
        ```
    2. `in 「list」`可以省列，默认等于`$@`（脚本或函数的参数值）
5. `select`

    ```shell
    # 多行
    select 「variable」 in 「list」; do
      「commands」
    done

    # 单行
    select 「variable」 in 「list」; do 「commands」; done
    ```
    1. 效果：

        1. select生成一个菜单，内容是列表list的每一项，并且每一项前面还有一个数字编号。
        2. Bash提示用户选择一项，输入它的数字编号。
        3. 用户输入以后，Bash会将该项的内容存在变量variable，该项的编号存入环境变量REPLY。如果用户没有输入，就按回车键，Bash会重新输出菜单，让用户选择。
        4. 执行命令体commands。
        5. 执行结束后，回到第一步，重复这个过程。
    2. `in 「list」`可以省列，默认等于`$@`（脚本或函数的参数值）

- `break`

    立即终止循环（`while`、`until`、`for-in`、`for`、`select`），程序继续执行循环块之后的语句。

- `continue`

    立即终止本轮循环，开始执行下一轮循环。

### 函数
```shell
fn() {  # 不能跟形参
  # 参数用：$「正整数」、$#、$@、$*
  # 函数体内直接声明的变量，属于全局变量，整个脚本都可以读取
  # 函数体内可以修改全局变量

  return # 可以返回空，也可以返回字符串
  # return之后不再执行
}

# 或

function fn() {
  # codes
}


# 调用时，直接写函数名，参数跟在函数名后面
fn 参数1 参数2
```

1. 函数总是在当前Shell执行

    >`source ./脚本`在当前Shell执行，`bash ./脚本`（或其他Shell）在新建的一个子Shell执行。
2. 同名执行优先级：

    别名 > 函数 > 脚本
3. 删除一个函数

    `unset -f 「函数名」`
4. 查看函数

    ```shell
    # 查看所有函数以及定义
    declare -f

    # 查看某函数以及定义
    declare -f 「函数名」
    ```

### 数组
1. 写入数组

    ```shell
    # 数组某项赋值，下标从0（或1，根据shell种类而不同）开始
    ARRAY[0]=value1
    ARRAY[1]=value2

    # 数组一次性赋值。可以指定下标
    ARRAY=(value1 value2 ... valueN)
    array=([2]=c [0]=a [1]=b)
    names=(hatter [5]=duchess alice)    # [0]=hatter [5]=duchess [6]=alice

    # 可以使用通配符
    mp3s=( *.mp3 )
    ```

    1. 没有赋值的数组元素的默认值是空字符串。
    2. 若给数组赋值时不设置下标，则默认给下标0（或1）的位置赋值。若引用不带下标的数组变量，则默认引用下标0（或1）的位置元素。

        ```shell
        declare -a foo
        foo=A
        echo ${foo[0]}      # A
        echo $foo           # A
        ```
2. 读取数组

    ```shell
    # 读取单个元素
    echo ${数组[下标]}

    # 读取所有元素
    echo ${数组[@]}
    echo ${数组[*]}
    ```

    - 双引号`""` 与 `${数组[@]}`和`${数组[*]}`的关系

        1. 若`"${数组[@]}"`，则元素内部的空格不分割元素（元素正常分割）。
        2. 若`"${数组[*]}"`，则所有成员变成单个字符串返回（变成一个元素）。
        3. 若`${数组[@]}`、`${数组[*]}`，则元素内部的空格也分割元素。

        ```shell
        # "${数组[@]}"
        activities=( swimming "water skiing" canoeing "white-water rafting" surfing )
        for act in "${activities[@]}"; do
          echo $act
        done

        # swimming
        # water skiing
        # canoeing
        # white-water rafting
        # surfing
        ```

        ```shell
        # "${数组[*]}"
        activities=( swimming "water skiing" canoeing "white-water rafting" surfing )
        for act in "${activities[*]}"; do
          echo $act
        done

        # swimming water skiing canoeing white-water rafting surfing
        ```

        ```shell
        # ${数组[@]} 或 ${数组[*]}
        activities=( swimming "water skiing" canoeing "white-water rafting" surfing )
        for act in ${activities[@]}; do # 或 *
          echo $act
        done

        # swimming
        # water
        # skiing
        # canoeing
        # white-water
        # rafting
        # surfing
        ```

        - 拷贝一个数组的方式：`数组2=( "${数组1[@]}" )`
        - 新增元素：`数组2=( "${数组1[@]}" "a b c" )`、`数组2=( "a b c" "${数组1[@]}" )`
3. 数组的长度（元素数量）

    ```shell
    echo ${#数组名[*]}
    echo ${#数组名[@]}
    ```
4. 数组的所有元素序号

    ```shell
    echo ${!数组名[@]}
    echo ${!数组名[*]}
    ```
5. 数组的元素提取

    ```shell
    echo ${数组名[@]:下标数:长度}   # 长度默认之后的所有
    ```
6. 数组末尾添加元素

    `+=`

    ```shell
    数组+=一个元素
    数组+=(元素1 元素2)
    ```
7. 删除数组

    1. 删除元素

        `unset 数组名[下标]`
    2. 删除数组

        `unset 数组名`
    3. 设置为空字符串

        不会把元素删除，只是把值设置为空字符串，查看元素序号还是能看到空字符串元素的下标。

        ```shell
        数组名[下标]=''
        数组名[下标]=
        ```

- 关联数组

    关联数组使用字符串而不是整数作为数组索引。

    ```shell
    declare -A colors           # 必须先声明为关联数组，才能用字符串作为索引
    colors["red"]="#ff0000"
    ```

8. 查看所有数组

    ```shell
    declare -a  # 查看所有数组
    declare -aA # 查看所有关联数组
    ```
### 默认环境变量
1. 行号，调用栈

    1. `LINENO`

        返回它在脚本里面的行号。
    2. `FUNCNAME`

        返回一个数组，内容是当前的函数调用堆栈。该数组的`0`项是当前调用的函数，`1`项是调用当前函数的函数，以此类推。
    3. `BASH_SOURCE`

        返回一个数组，内容是当前的脚本调用堆栈。该数组的`0`项是当前执行的脚本，`1`项是调用当前脚本的脚本，以此类推。
    4. `BASH_LINENO`

        返回一个数组，内容是每一轮调用对应的行号。`${BASH_LINENO[$i]}`跟`${FUNCNAME[$i]}`是一一对应关系，表示${FUNCNAME[$i]}在调用它的脚本文件${BASH_SOURCE[$i+1]}里面的行号。
2. 自定义用户命令行的字符显示

    `PS1`、`PS2`、`PS3`、`PS4`

### 启动Bash
用户每次使用Shell，都会开启一个与Shell的Session（对话）。

>以下顺序针对`bash`。若使用其他shell时（如：`zsh`等。查看或设置：[系统shell类型](https://github.com/realgeoffrey/knowledge/blob/master/工具使用/命令行备忘/README.md#系统shell类型)），则执行启动脚本的顺序和文件会变化，详情可查看：[关于Linux下Bash与Zsh启动档的载入顺序研究](https://blog.miniasp.com/post/2021/07/26/Bash-and-Zsh-Initialization-Files)、[Zsh/Bash startup files loading order (.bashrc, .zshrc etc.)
](https://shreevatsa.wordpress.com/2008/03/30/zshbash-startup-files-loading-order-bashrc-zshrc-etc/)。

1. 登录Session、login shell

    用户登录系统以后，系统为用户开启的原始Session，通常需要用户输入用户名和密码进行登录。

    1. 登录Session一般进行整个系统环境的初始化，启动的初始化脚本依次如下：

        1. `/etc/profile`：所有用户的全局配置脚本。

            >Linux发行版更新的时候，会更新`/etc`里面的文件（如：`/etc/profile`，因此不要直接修改这个文件）。
        2. `/etc/profile.d`目录里面所有`.sh`文件。

            >若想修改所有用户的登录环境，就在`/etc/profile.d`目录里面新建.sh脚本。
        3. **`~/.bash_profile`**：用户的个人配置脚本。

            >若想修改你个人的登录环境，一般是写在`~/.bash_profile`里面。

            1. `~/.bash_login`：

                若`~/.bash_profile`没找到，则尝试执行这个脚本（C shell的初始化脚本）。
            2. `~/.profile`：

                若`~/.bash_profile`和`~/.bash_login`都没找到，则尝试读取这个脚本（Bourne shell和Korn shell的初始化脚本）。
    2. `bash --login`，会强制执行登录Session会执行的脚本。
    3. `bash --noprofile`，会跳过上面这些Profile脚本。
2. 非登录Session、non-login shell

    用户进入系统以后，手动新建的Session，如：在命令行执行`bash`。

    1. 非登录Session不会进行环境初始化，启动的初始化脚本依次如下：

        1. `/etc/bash.bashrc`：对全体用户有效。
        2. **`~/.bashrc`**：仅对当前用户有效。

            对用户来说，`~/.bashrc`通常是最重要的脚本。非登录Session默认会执行它，而登录Session一般也会通过调用执行它。

            >执行脚本相当于新建一个非互动的Bash环境，但是这种情况不会 ~~调用`~/.bashrc`~~。
    2. `bash --norc`，可以禁止在非登录Session执行`~/.bashrc`脚本。
    3. `bash --rcfile 「文件名」`，指定另一个脚本代替`.bashrc`。

- `~/.bash_logout`

    1. 在每次退出Session时执行，通常用来做一些清理工作和记录工作，如：删除临时文件，记录用户在本次Session花费的时间。
    2. 若没有退出时要执行的命令，则这个文件也可以不存在。
