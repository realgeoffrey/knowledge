# JS正则表达式

## 目录
1. [创建RegExp对象](#创建regexp对象)
1. [特殊字符](#特殊字符)
1. [正则函数](#正则函数)
1. [正则表达式的性能](#正则表达式的性能)

---
### 创建RegExp对象
1. 创建方法

    若要匹配字符`\`：

    1. 字面量

        ```js
        /\\/gimuy   // 对`(` `)` `[` `]` `{` `}` `\` `/` `^` `$` `|` `?` `*` `+` `.` 进行转义（添加`\`）
        ```

        加载JS脚本后就编译（compilation），更好的性能。
    2. 构造函数

        ```js
        // 第一个参数为正则表达式字面量，需要转义特殊字符
        // 对`(` `)` `[` `]` `{` `}` `\` `/` `^` `$` `|` `?` `*` `+` `.` 进行转义（添加`\`）
        new RegExp(/\\/, 'gimuy')   // /\\/gimuy
        new RegExp(/\(\)/)          // /\(\)/


        // 第一个参数为字符串，则需要把字符串里`正则表达式需要转义的特殊字符`（除去原本在字符串中作为转义的`\`）前添加`\\`
        // （一个是正则的转义字符`\`，一个是字符串转义前一个字符串的转义字符`\`）
        new RegExp('\\\\', 'gimuy') // /\\/gimuy
        new RegExp('\\(\\)')        // /\(\)/

        // 因此若要把字符串作为正则表达式（忽略特殊字符含义，仅表示字面含义），需要
        // 先添加`\\`，才能传入正则构造函数
        const regStr = 字符串.replace(/([()[\]{}\\/^$|?*+.])/g, '\\$1')   // 因为字符串的replace会忽略转义字符
        const regexp = new RegExp(regStr)


        // 第一个参数为字符串时，可以使用变量
        const gap = 3;
        const reg = new RegExp(`\\B(?=(\\d{${gap}})+(?!\\d))`, "g");
        // reg 等价于 /\B(?=(\d{3})+(?!\d))/g
        ```

        运行JS脚本时编译（runtime compilation），仅在需要传参数情况下才使用此方式。
2. 标志（修饰符）

    1. `g`（不添加则默认：每次都重新匹配、匹配到字符串结束）：

        global，找到所有匹配而不是在第一个匹配后停止（影响lastIndex）。

        >1. 若不带g，则在正则过程中，字符串是从左至右匹配的，当匹配成功就不再继续向右匹配了；若带g，则会从头到尾的把正确匹配的字符串挑选出来。
        >2. 影响正则相关方法的结果。
    2. `i`（不添加则默认：大小写敏感）：

        ingore case，忽略大小写。
    3. `m`（不添加则默认：单行搜索）：

        multiple lines，多行搜索（`^`和`$`工作范围在每行的起始）。
    4. `u`（不添加则默认：按照ES5来处理字符，1个字仅有2个字节）：

        Unicode，用来正确处理大于`\uFFFF`的Unicode字符（对于大于`\uFFFF`的字，把4字节的字符当做单独1个字来解析，否则当做2个2字节的字），把`\u{}`当做Unicode（否则当做正则内容）。
    5. `y`：

        sticky，必须从上一次匹配成功的下一个位置开始（`lastIndex`），作用是达到`^`在全局匹配中都有效。
    6. `s`：

        使得`.`可以匹配任意单个字符（包括终止符）。
    7. `d`：

        使匹配数组新增`indices`属性，记录捕获的每个编号组的开始和结束索引。

### 特殊字符
在正则表达式`/字面量/`中的内容：

1. 需要转义的特殊字符

    `(` `)` `[` `]` `{` `}` `\` `^` `$` `|` `?` `*` `+` `.` `/`（`/`仅在正则字面量中需要转义）

    因为有特殊含义，所以在使用以上元字符的字面值时必须对其进行`\`转义（在`[]`或`[^]`中转义是可选的；在`[]`或`[^]`中无法使用这些特殊字符的元字符含义，只能作为字面值）。

    >可以给除了特殊字符的所有字符前面添加`\`（不推荐）。
2. 元字符

    1. 字符类别

        | 字符 | 表示的意义 |
        | :--- | :--- |
        | `.` | 匹配除了~~终止符~~之外的任意字符（终止符：`\u000a`换行符`\n`、`\u000d`回车符`\r`、`\u2028`行分隔符、`\u2029`段分隔符）。 |
        | `\d` | 匹配数字。等价于：`[0-9]`。 |
        | `\D` | 匹配不是数字。等价于：`[^0-9]`。 |
        | `\w` | 匹配字母、数字、下划线。等价于：`[A-Za-z0-9_]`。 |
        | `\W` | 匹配不是字母、数字、下划线。等价于：`[^A-Za-z0-9_]`。 |
        | `\s` | 匹配不可见字符，包括空格、制表符、换页符、换行符和其他Unicode空格。等价于：`[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]`。 |
        | `\S` | 匹配可见字符。等价于：`[^ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]`。 |
        | `\t` | 匹配水平制表符（tab）。 |
        | `\r` | 匹配回车符（carriage return）。 |
        | `\n` | 匹配换行符（linefeed）。 |
        | `\v` | 匹配垂直制表符（vertical tab）。 |
        | `\f` | 匹配换页符（form-feed）。 |
        | `[\b]` | 匹配退格符（backspace）。 |
        | `\0` | 匹配 NUL 字符。不要在此后面跟小数点。 |
        | `\cA至Z的一个字母` | 匹配字符串中的一个控制字符。如：`/\cM/`匹配字符串中的control-M。 |
        | `\x两个16进制数` | 匹配16进制数指定的字符。 |
        | `\u四个16进制数` | 匹配16进制数指定的UTF-16字符。 |
        | `\u{四至五个16进制数}` | 匹配16进制数指定的字符。 |
        | `\其他字符` | 匹配（转义）特殊字符。 |
    2. 字符集合

        | 字符 | 表示的意义 |
        | :--- | :--- |
        | `[xyz]`或`[x-z]` | 匹配集合中的任意一个字符。也以使用连字符`-`指定一个连续范围。内部可以不转义特殊字符（可选），除非不得已，e.g. `/[\]]/`、`/[\\]/`。 |
        | `[^xyz]`或`[^x-z]` | 匹配任意不在括号内的字符。也可通过使用连字符`-`指定一个范围内的字符。内部可以不转义特殊字符（可选），除非不得已，e.g. `/[^\]]/`、`/[^\\]/`。 |

        >不支持字符集合内包含 需要转义的特殊字符 的元字符含义（会变成字面值）。
    3. 边界

        | 字符 | 表示的意义 |
        | :--- | :--- |
        | `^` | 匹配输入`/`字符串的开始。若多行（multiline）标志被设为 true，则该字符也会匹配一个断行（line break）符后的开始处。 |
        | `$` | 匹配输入`/`字符串的结尾。若多行（multiline）标志被设为 true，则该字符也会匹配一个断行（line break）符的前的结尾处。 |
        | `\b` | 匹配一个零宽单词边界（zero-width word boundary），如：一个字母与一个空格之间。e.g. `/\ba/`匹配`aaa aaa`中的第一和第四的`a`。它不匹配任何内容，因此`/\w\b\w/`将不能匹配任何字符串，因为一个单词中的字符永远也不可能被一个非词汇字符与一个词汇字符同时紧跟。 |
        | `\B` | 匹配一个零宽非单词边界（zero-width non-word boundary），如：两个字母之间或两个空格之间。e.g. `/\Ba/`匹配`aaa aaa`中的第二、第三、第五和第六的`a`。 |

    >下面的`整体`也可以是正则表达式。如：`((a|b).+[abc]){2}`。

    4. 分组

        | 字符 | 表示的意义 |
        | :--- | :--- |
        | `(整体)` | 匹配`整体`并且捕获匹配项。 这被称为捕获括号（capturing parentheses）。 |
        | `(?:整体)` | 匹配`整体`不会捕获匹配项。这被称为非捕获括号（non-capturing parentheses）。<br>e.g. `/(?:abc){2}/`匹配`abcabc`；`/abc{2}/`匹配`abcc` |
        | `(?<名字>整体)` | 具名捕获组：匹配`整体`并将其存储在返回的匹配项的`groups`属性中，该属性位于`<名字>`指定的名称下。<br>e.g. `/(?<name1>a+)(?<name2>b+)/.exec('aaaabb').groups`输出`{name1: 'aaaa', name2: 'bb'}` |
        | `\一个正整数` | 一个反向引用（back reference），指向正则表达式中第 n 个捕获匹配项中匹配的字符串。 |

        >1. 括号分组可以嵌套，外部的分组比内部分组的编号靠前。
        >2. `RegExp.$1`~`RegExp.$9`值为String类型，返回上一次正则表达式匹配中第n个分组所匹配的文本。
        >3. `分组`可用于下面的`数量词`，如：`(abc)|(def)`匹配`abc`或`def`。
    5. 数量词

        | 字符 | 表示的意义 |
        | :--- | :--- |
        | `x?` | 匹配前面的模式`x`的0或1次。等价于：`{0,1}`。 |
        | `x*` | 匹配前面的模式`x`的0或多次。等价于：`{0,}`。 |
        | `x+` | 匹配前面的模式`x`的1或多次。等价于：`{1,}`。 |
        | `x{一个正整数}` | 前面的模式`x`的连续出现n次时匹配。 |
        | `x{一个正整数,}` | 前面的模式`x`的连续出现至少n次时匹配。 |
        | `x{一个正整数,一个正整数}` | 前面的模式`x`的连续出现至少n次，至多m次时匹配。 |
        | `x??` `x*?` `x+?` `x{n}?`<br>`x{n,}?` `x{n,m}?` | **惰性模式**，只进行最小限度的匹配（不加`?`则默认：贪婪模式）。 |
        | `x\|y` | 匹配`x`或`y`。<br>`\|`的匹配顺序通常是 ​从左到右（先尝试左边的分支，若失败则再尝试右边的分支）。但在某些情况下，JS的正则引擎可能会优化匹配顺序，导致右边的分支先被匹配（若右边的分支更短或更简单或更快匹配成功）。 |

        >贪婪模式（默认）：趋向于最大长度匹配。当贪婪匹配之后还有需要匹配的内容，则回退缩短贪婪匹配内容（回溯）。
    6. 零宽断言

        | 字符 | 表示的意义 |
        | :--- | :--- |
        | `x(?=整体)` | 零宽正向先行断言。只有当`x`后面紧跟着`整体`时（`整体`不消耗字符），才匹配`x`。 |
        | `x(?!整体)` | 零宽负向先行断言。只有当`x`后面不是紧跟着`整体`时（`整体`不消耗字符），才匹配`x`。 |
        | `(?<=整体)x` | 零宽正向后行断言。只有当`整体`后面紧跟着`x`时（`整体`不消耗字符），才匹配`x`。（注意浏览器兼容） |
        | `(?<!整体)x` | 零宽负向后行断言。只有当`整体`后面不是紧跟着`x`时（`整体`不消耗字符），才匹配`x`。（注意浏览器兼容） |

        >1. 零宽断言（Zero-width Assertion）：在匹配的过程中，只匹配位置，断言在匹配时不会"消耗"字符串（也不捕获任何内容），它只是对位置进行条件判断。
        >2. 先行（Lookahead）：表示匹配字符发生在匹配位置之前。
        >3. 后行（Lookbehind）：表示匹配字符发生在匹配位置之后。
        >4. 正向（Positive）：匹配括号中的表达式，即只有当条件成立时，匹配字符才成功。
        >5. 负向（Negative）：不匹配括号中的表达式，即只有当条件不成立时，匹配字符才成功。

>正则表达式测试：[测试模拟](http://regexr.com/)、[图像解释](https://regexper.com/)。

### 正则函数
1. RegExp对象的方法

    1. `regexp.test(str)`：

        判断正则表达式与指定的字符串是否匹配。返回`true`或`false`。
    2. `regexp.exec(str)`：

        >`regexp.exec(str)`（带不带`g`不影响）返回结果与`str.match(regexp)`不带`g`标志的结果相同。

        指定的一段字符串执行搜索匹配操作。返回`数组`或`null`。

        若成功匹配，则返回一个数组，并且更新正则表达式对象的属性。返回的数组包括匹配的字符串作为第一个元素，紧接着多个元素对应被捕获的字符串，数组还额外拥有`index`和`input`属性。

        ><details>
        ><summary>e.g.</summary>
        >
        >1. 执行：
        >
        >    ```javasscript
        >    var regexp = /quick\s(brown).+?(jumps)/ig;
        >    var arr1 = regexp.exec('The Quick Brown Fox Jumps Over The Lazy Dog');
        >    ```
        >
        >    产生的结果：
        >
        >    | 返回对象[属性/索引] | 描述 | 例子中的值 |
        >    | :--- | :--- | :--- |
        >    | `arr1[0]` | 匹配得到的字符串 | `'Quick Brown Fox Jumps'` |
        >    | `arr1[1]`~`arr1[n]` | 捕获项 | `arr1[1] = 'Brown'`<br>`arr1[2] = 'Jumps'` |
        >    | `arr1.index` | 匹配到的字符位于原始字符串的基于0的索引值 | `4` |
        >    | `arr1.input` | 原始字符串 | `'The Quick Brown Fox Jumps Over The Lazy Dog'` |
        >
        >    | 正则对象[属性/索引] | 描述 | 例子中的值 |
        >    | :--- | :--- | :--- |
        >    | `regexp.lastIndex` | 下一次匹配开始的位置 | `25` |
        >    | `regexp.source` | 正则模式的字符串 | `'quick\s(brown).+?(jumps)'` |
        >    | `regexp.flags` | 返回修饰符 | `'gi'` |
        >    | `regexp.global` | 是否使用了`g`标记 | `true` |
        >    | `regexp.multiline` | 是否使用了`m`标记 | `false` |
        >2. 再次执行：
        >
        >    ```javasscript
        >    var arr2 = regexp.exec('0123456789012345678901234 Quick Brown Fox Jumps');
        >    ```
        >
        >    产生的结果：
        >
        >    | 返回对象[属性/索引] | 描述 | 例子中的值 |
        >    | :--- | :--- | :--- |
        >    | `arr2[0]` | 匹配得到的字符串 | `'Quick Brown Fox Jumps'` |
        >    | `arr2[1]`~`arr2[n]` | 捕获项 | `arr2[1] = 'Brown'`<br>`arr2[2] = 'Jumps'` |
        >    | `arr2.index` | 匹配到的字符位于原始字符串的基于0的索引值 | `26` |
        >    | `arr2.input` | 原始字符串 | `'0123456789012345678901234 Quick Brown Fox Jumps'` |
        >
        >    | 正则对象[属性/索引] | 描述 | 例子中的值 |
        >    | :--- | :--- | :--- |
        >    | `regexp.lastIndex` | 下一次匹配开始的位置 | `47` |
        >
        >- 没有 ~~`g`~~
        >
        >    ```javascrpit
        >    var regexp2 = /quick\s(brown).+?(jumps)/i;
        >    var arr3 = regexp2.exec('The Quick Brown Fox Jumps Over The Lazy Dog');
        >
        >    console.log(regexp2.lastIndex)  // => 0
        >    ```
        ></details>
    3. 正则表达式的属性：

        1. `RegExp.prototype.source`

            当前正则表达式对象的模式文本的字符串，该字符串不会包含正则字面量两边的反斜线以及任何标志字符，并会自动添加字符串的`\`转义（基本仅对`\`、`"`、`'`转义）。

            <details>
            <summary>e.g.</summary>

            ```js
            /\w/g.source === '\\w';                  // true
            new RegExp('\\w', 'g').source === '\\w'; // true
            ```
            </details>
        2. `实例.lastIndex`

            下次匹配开始的字符串索引位置。只有正则表达式使用了表示全局检索的`g`标志时，`lastIndex`才起作用。
        3. `RegExp.prototype.flags`

            返回修饰符。
        4. `RegExp.prototype.global`

            是否设置了`g`修饰符。
        5. `RegExp.prototype.ignoreCase`

            是否设置了`i`修饰符。
        6. `RegExp.prototype.multiline`

            是否设置了`m`修饰符。
        7. `RegExp.prototype.unicode`

            是否设置了`u`修饰符。
        8. `RegExp.prototype.sticky`

            是否设置了`y`修饰符。
        9. `RegExp.prototype.dotAll`

            是否设置了`s`修饰符。
        10. `RegExp.prototype.hasIndices`

            是否设置了`d`修饰符。
2. String对象的方法

    1. `str.match(regexp)`：

        当字符串匹配到正则表达式时，方法返回`匹配项`，否则返回`null`。

        - 匹配到的情况：

            1. 若正则表达式没有`g`标志，则返回和`regexp.exec(str)`（带不带`g`不影响）相同的结果的`数组`（包含匹配的字符串、捕获项，还拥有`index`和`input`属性）。
            2. 若正则表达式包含`g`标志，则返回一个`包含所有匹配结果的数组`。
    2. `str.matchAll(regexp)`
    3. `str.search(regexp)`：

        判断字符串对象与一个正则表达式是否匹配，返回`正则表达式在字符串中首次匹配项的索引`，否则返回`-1`。
    4. `str.replace(regexp|substr, newSubStr|function[, flags])`：

        方法使用一个替换值（replacement）替换掉一个匹配模式（pattern）在原字符串中某些或所有的匹配项，并返回替换后的`字符串`（不改变调用的字符串对象）。

        被替换的参数`newSubStr`值类型：

        1. 使用字符串作为参数

            替换的字符串若拥有以下内容，则会被解析成特殊内容：

            | 变量名 | 代表的值 |
            | :--- | :--- |
            | `$$` | 插入一个`$`。 |
            | `$&` | 插入匹配的子串。 |
            | `` $` `` | 插入当前匹配的子串左边的内容。 |
            | `$'` | 插入当前匹配的子串右边的内容。 |
            | `$n` | 若第一个参数是RegExp对象，并且n是个10进制的数字，则插入第n个捕获匹配项的内容。 |

            >e.g. `str.replace(regexp, '$$ $& $1');`，特殊字符就是替换字符串的一部分。
        2. 使用函数作为参数

            当匹配执行后，该函数就会执行，函数的返回值作为替换字符串。

            >若第一个参数是正则表达式且为全局匹配模式，则这个方法将被多次调用、每次匹配都会被调用。

            函数参数为：

            | 参数顺序 | 代表的值 |
            | :--- | :--- |
            | `arguments[0]` | 匹配的子串。 |
            | `arguments[1]`~`arguments[n]` | 若replace()方法的第一个参数是一个RegExp对象，则代表第n个捕获匹配项的内容。 |
            | 倒数第二个参数 | 匹配到的子字符串在原字符串中的偏移量。 |
            | 倒数第一个参数 | 被匹配的原字符串。 |
    5. `str.split([separator][, limit])`：

        以separator为间隔，把字符串分割成一个字符串`数组`。

        1. `separator`：可以是一个字符串或正则表达式，指定用来分割。 若忽略参数，则返回整个字符串的数组形式；若是一个空字符串，则返回单字符组成的数组。
        2. `limit`：一个整数，限定返回的分割片段数量。

### 正则表达式的性能
>正则表达式是匹配模式：要么匹配字符，要么匹配位置。

1. 正则表达式的实现类型：

    1. DFA（Deterministic Finite Automaton，确定性有限状态自动机）

        即匹配的路径是确定的。所以时间空间复杂度是确定的。但是这类正则能实现的功能很有限。目前复杂点的正则使用的都是NFA。
    2. NFA（Nondeterministic Finite Automaton，非确定性有限状态自动机）

        匹配的路径是不确定的。会读取正则表达式的每一个字符，拿去和目标字符串匹配，匹配成功就换正则表达式的下一个字符，反之就继续和目标字符串的下一个字符进行匹配。这就是NFA为什么可能会造成ReDoS攻击的原因。不恰当的正则表达式对于输入的原字符串，即便多加一个字符，执行的时间可能会成倍的增长。

        ><details>
        ><summary>e.g.</summary>
        >
        >`'10101010110101001100101010101010101010101010101010000'.match(/([01]+)+b/)`
        >
        >长度还不到100，在浏览器执行就会让进程卡死（死循环、回溯过多）：
        >
        >有两个加号，而且都是贪婪匹配，这会导致内层的加号首先尝试把整个字符串匹配完，然后外层的加号再把这个模式重复，然而重复的时候又会发生一次内层加号的匹配，而两个加号匹配完成后又发现后面并没有一个b，于是回溯到外层括号（因为外层是后匹配的，所以先回溯到它）减少其匹配数量，每次回溯都会有很多条分支可走（加号可以选择匹配1到无穷多个，此例中即为匹配到字符串的结束），最后直到回溯到最开始的两个字符，上例中即10，然后发现第三个符号依然不是b，然后才结束。
        >
        >每一次面临选择，都有从该位置直到结束那么多种选择，时间复杂度大概是n的阶乘
        ></details>
2. ReDoS（Regular expression Denial of Service，正则表达式拒绝服务攻击）

    当开发人员使用正则表达式来对用户输入的数据进行有效性校验，若编写校验的正则表达式存在缺陷或者不严谨时，则攻击者可以构造特殊的字符串来大量消耗服务器的系统资源，造成服务器的服务中断或停止。

    - 防御措施

        防范手段只是为了降低风险而不能百分百消除ReDoS这种威胁。避免这种威胁的最好手段是尽量减少正则在业务中的使用场景。

        1. 降低正则表达式的复杂度，尽量少用分组
        2. 严格限制用户输入的字符串长度（特定情况下）
        3. 使用单元测试、模糊测试保证安全
        4. 添加服务器性能监控系统
3. 正则表达式的优化

    1. 尽可能准确地匹配目标字符串，以减少不必要的回溯。
    2. 少用贪婪模式：贪婪模式容易引起回溯问题，可以使用独占模式来避免回溯。
    3. 减少分支选择：

        分支选择类型`(X|Y|Z)`的正则表达式会降低性能，在开发的时候要尽量减少使用。如果一定要用，可以通过以下几种方式来优化：

        1. 考虑选择的顺序，将比较常用的选择项放在前面，使他们可以较快地被匹配；
        2. 可以尝试提取共用模式，例如，将`(abcd|abef)`替换为`ab(cd|ef)`，后者匹配速度较快，因为 NFA 自动机会尝试匹配 ab，如果没有找到，就不会再尝试任何选项；
        3. 用多次匹配来替代简单的分支选择，如：`indexOf('X')`+`indexOf('Y')`+`indexOf('Z')`来替代正则匹配`(X|Y|Z)`。
    4. 减少捕获嵌套

        捕获组是指把正则表达式中，子表达式匹配的内容保存到以数字编号或显式命名的数组中，方便后面引用。一般一个`()`就是一个捕获组，捕获组可以进行嵌套。

        非捕获组则是指参与匹配却不进行分组编号的捕获组，其表达式一般由`(?:exp)`组成。
    5. 避免嵌套数量词

        e.g. `(a+)*`
    6. 避免带有`|`的重叠情况

        e.g. `(a|a)*`
    7. 避免使用回溯

        e.g. `(a.*) \1`
